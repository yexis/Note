1. preparation
2. Go
   - 基础知识
   - 常用包
   - 并发编程
3. redis
   - 学习思路
4. summary



![image-20200712161408733](/home/yex/.config/Typora/typora-user-images/image-20200712161408733.png)

---

### About me



### About Golang

###### 一、基础结构

1. **可见性**

   Go语言没有像其他语言的public、protected、private等访问控制修饰符，go通过字母大小写来控制可见性。

   如果定义的常量、变量、类型、接口、结构、函数等的名称是大写字母开头，说明其是可导出的，即可以被包外的其他包访问；非大写字母开头的是不可导出的result，只能在本包内使用（private）。

###### 二、基本数据类型

1. **bool**
2. **string**
3. **数值类型**
4. **错误类型**



---

###### 三、基础语法

1. **数组和切片**

   在Go语言中，数组和切片是两种不同的数据结构。

   在Go语言中，数组是一种具有相同类型固定大小的数据结构。

   **数组：**

   ![image-20200712163159931](/home/yex/.config/Typora/typora-user-images/image-20200712163159931.png)

   特点：内存连续、随机访问、值拷贝

   **切片：**动态数组

   1. 切片是数组的一个引用，引用类型。自身是结构体，值拷贝传递
   2. 可变数组：长度可以改变
   3. 不能超出数组限制

   

   ![image-20200712163406724](/home/yex/.config/Typora/typora-user-images/image-20200712163406724.png)

   特点：

   > 扩容：
   >
   > - 如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。
   > - 如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。

2. **函数与方法**

   函数：

   > ​    无需声明原型
   > ​    支持不定 变参
   > ​    支持多返回值
   > ​    支持命名返回参数
   > ​    支持匿名函数和闭包
   > ​    作为一等公民，函数也是一种类型
   > ​    不支持 重载 
   > ​    不支持 默认参数 

   匿名函数：不需要定义函数名的一种函数实现方式

   

   闭包：

   > 闭包是由函数及其相关引用环境组合而成的实体

   ```
   unc main() {
   	n := 0
   	f := func() int {
   		n += 1
   		return n
   	}
   	fmt.Println(f())  
   	fmt.Println(f())
   }
   ```

   n（环境） 和  f（函数） 组成的就是一个闭包。

   闭包的应用：

   - 隔离数据：隔离不允许调用者查看的数据，输出指定的结果
   - 函数装饰器：函数做为参数值，且调用者根据传递进来的不同函数产生不同的反应
   - 异步，链式调用：类似js中的promise的用法

   ```js
   //js
   f1(a, b, function(result) {
     f2(result, function(result) {
       f3(result, function(result) {
         // code here
       });
     });
   });
   //go
   go func() {
     result := f1(a, b)
     result = f2(result)
     result = f3(result)
     // Code here
   }()
   ```

   

   延迟调用：

   

   方法：

   > 包含了接收者的方法

   - golang不是一个纯粹的面向对象的语言，go不支持类定义。所以需要通过在一个命名类型上建立方法来实现面向对象。

     | Values |  Methods Receivers   |
     | :----: | :------------------: |
     | **T**  |      **(t T)**       |
     | ***T** | **(t T) and (t *T)** |

3. **接口**

   > 一种定义了对象行为的类型
   >
   > 在golang中，任何类型都实现了空接口，所以接口可以存储任何类型变量

   在golang中方法是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现了该接口（无需显示声明***implements***）。与OOP类似，接口定义类型具有的方法，类型决定方法的实现。

4. 未知

   

5. **并发编程**

   - goroutine（待查阅）

     协程，由go runtime调度与管理。对go 特定任务的封装，并发的最小单位。

   - 并发安全

     互斥锁：一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。

     读写锁：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。

     原子操作：

   - channel

     宗旨：

     > 通过通信共享内存而不是通过共享内存而实现通信。

     设计：

     - 基于数组的循环队列，有缓冲的channel用它暂存数据

     - 基于链表的单向队列，用于保存阻塞在此channel上的goroutine

     ![image-20200712165318132](/home/yex/.config/Typora/typora-user-images/image-20200712165318132.png)

     特性：

     - 线程安全通过mutex实现
     - FIFO通过循环队列实现
     - 通信通过共享hchan+数据拷贝实现
     - 阻塞：阻塞goroutine自己挂起实现，唤醒通过对方goroutine唤醒

   - GMP调度

     G：goroutine协程
     
     M：操作系统 thread线程
     
     P：processor处理器
     
     ![image-20200712170609401](/home/yex/.config/Typora/typora-user-images/image-20200712170609401.png)
     
     
     
     说明：

###### 四、常用标准库

1. **fmt**
2. **log**
3. **time**
4. **Strconv**

###### 五、Redis

### Summary

核心差异：

- 并发编程
- 面向接口编程build
- 函数多返回值
- 延后执行
- 异常处理
- 强大且高性能的网络编程
- 内存管理及回收 gcc
- 代码跨平台及交叉编译
- 