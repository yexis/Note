### Title 

##### 1 emphasis



##### 2 key points

######  莫队可以用来做什么



##### 3 thought



##### 4 code

[3636. 查询超过阈值频率最高元素](https://leetcode.cn/problems/threshold-majority-queries/)

```cpp
/*
算法：
回滚莫队

时间复杂度： 
O(n * sqrt(q))

核心思想：
1. 把询问区间按照左端点所在块进行分组，左端点在同一个块的询问分到同一组；
2. 对于每个块，按照右端点排序，使得右端点一直向右移动，左端点只在块内抖动；
3. 这样，相邻询问间的交集能尽可能大，进而尽量减少增删元素的次数

假设将区间分成k个，每个区间的长度为B；
对于每个块，右端点的平均移动次数为 n/2；
对于所有询问，右端点的总移动次数为 nk/2 = n^2/2B；左端点的平均移动次数为 qB
所以，总移动次数为 n^2/2B + qB，由基本不等式可知，当 B = n / sqrt(2q) 时取到最小值，为保证B为正整数，实际可向上取整即ceil(n / sqrt(2q))

细节：
由于当我们考虑左端点的最大移动次数时，时间复杂度也在可接受范围内，所以对于每个询问，可以将左端点重置(更新到起始点，即当前块右端点)，这样就不用考虑删除了

*/

class Solution {
public:
    vector<int> subarrayMajority(vector<int>& a, vector<vector<int>>& qs) {
        int n = a.size(), m = qs.size();

        unordered_map<int, int> cnt;
        int max_cnt = 0, min_val = 0;
        auto add = [&](int x) {
            int c = ++cnt[x];
            if (c > max_cnt) {
                max_cnt = c;
                min_val = x;
            } else if (c == max_cnt) {
                min_val = min(min_val, x);
            }
        };
        vector<int> ans(m, -1);
        int block_size = ceil(n / sqrt(m * 2));

      	// 询问区间
        struct Query {
            int bid; // 块id
            int l;
            int r;   // 左闭右开
            int threshold;
            int qid; // 询问id
        };

        vector<Query> pr;
        for (int i = 0; i < m; i++) {
            auto&q = qs[i];
            int l = q[0], r = q[1] + 1, threshold = q[2];
            // 大区间：离线
            if (r - l > block_size) {
                pr.emplace_back(l / block_size, l, r, threshold, i);
                continue;
            }
            // 小区间：暴力
            for (int j = l; j < r; j++) {
                add(a[j]);
            }
            if (max_cnt >= threshold) {
                ans[i] = min_val;
            }
            cnt.clear();
            max_cnt = 0;
        }

      	// 优先按照 块id 升序
      	// 其次按照 右端点 升序
        sort(pr.begin(), pr.end(), [&](const auto& aa, const auto& bb) {
            if (aa.bid == bb.bid) {
                return aa.r < bb.r;
            }
            return aa.bid < bb.bid;
        });

        int r;
        for (int i = 0; i < pr.size(); i++) {
            auto& q = pr[i];
            // 右端点的起点 设置为当前块右边界的下一个点
            int l0 = (q.bid + 1) * block_size;
            // 遍历到新的块
            if (i == 0 || q.bid > pr[i - 1].bid) {
                r = l0;
                cnt.clear();
                max_cnt = 0;
            }

            // 右端点只能向右移动，从 r 移动到 q.r
            for (; r < q.r; r++) {
                add(a[r]);
            }
            int tmp_max_cnt = max_cnt;
            int tmp_min_val = min_val;

            // 左端点从 l0 移动到 q.l
            for (int j = q.l; j < l0; j++) {
                add(a[j]);
            }
            if (max_cnt >= q.threshold) {
                ans[q.qid] = min_val;
            }

            // 回滚：左端点回到当前块的右边界
            max_cnt = tmp_max_cnt;
            min_val = tmp_min_val;
            for (int j = q.l; j < l0; j++) {
                --cnt[a[j]];
            }
        }
        return ans;
    }
};
```



##### 5 summary

