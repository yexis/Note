### Title 回滚莫队

##### 1 emphasis

- 回滚莫队



##### 2 key points

###### 2.1 回滚莫队和普通莫队的区别

**普通莫队和回滚莫队的主要区别在于处理删除操作的方式**

普通莫队：

- 支持添加和删除操作，通过添加和删除来维护区间当前的状态
- 适用于添加和删除都很容易实现的场景（**统计区间内不同元素的个数、区间内元素出现次数等**）

回滚莫队：

- 只支持添加操作，不支持删除操作（**通过回滚间接实现删除操作**）
- 适用于维护历史状态，保存历史状态便于回滚（**维护最大值、最小值、并查集**）
- 如果题意询问区间最值类问题，需要使用回滚莫队



##### 3 thought



##### 4 code

**【左闭右闭】**

例题：https://leetcode.cn/contest/weekly-contest-476/problems/count-stable-subarrays/description/

```cpp
using ll = long long;
class Solution {
public:
    // 区间定义
    struct Query {
        int bid; // 块id
        int l;
        int r;   // 左闭右闭
        int threshold;
        int qid; // 询问id
        bool operator<(const auto& that) const {
            if (bid == that.bid) {
                return r < that.r;
            }
            return bid < that.bid;
        }
    };
    vector<long long> countStableSubarrays(vector<int>& a, vector<vector<int>>& qs) {
        int n = a.size();
        int m = qs.size();
        
        int dp[n]; for (int i = 0; i < n; i++) dp[i] = 1;
        for (int i = 1; i < n; i++) if (a[i] >= a[i - 1]) dp[i] = dp[i - 1] + 1;
        

        int dp2[n]; for (int i = 0; i < n; i++) dp2[i] = 1;
        for (int i = n - 2; i >= 0; i--) if (a[i] <= a[i + 1]) dp2[i] = dp2[i + 1] + 1;
        

        // =========== 回滚莫队 模板开始
        ll sum = 0;
        auto add = [&](ll x) {
            sum += x;
        };
        
        vector<ll> ans(m);
        int block_size = ceil(n / sqrt(m * 2));
        
        vector<Query> pr;
        for (int i = 0; i < m; i++) {
            auto&q = qs[i];
            int l = q[0], r = q[1];
            // 大区间：离线
            if (r - l + 1 > block_size) {
                pr.emplace_back(l / block_size, l, r, 0, i);
                continue;
            }
            // 小区间：暴力
            for (int j = l; j <= r; j++) {
                int len = min(dp[j], j - l + 1);
                ans[i] += len;
            }
        }

        sort(pr.begin(), pr.end());

        int r;
        for (int i = 0; i < pr.size(); i++) {
            auto& q = pr[i];
            // 右端点的起点 设置为当前块右边界的下一个点
            int l0 = (q.bid + 1) * block_size;
            // 遍历到新的块
            if (i == 0 || q.bid > pr[i - 1].bid) {
                r = l0;
                sum = 0;
            }

          	// 对于大区间
            // 右端点只能向右移动，从 r 移动到 q.r
            for (; r <= q.r; r++) {
                add(min(dp[r], r - l0 + 1));
            }
            
            ll tmp_sum = sum;
            
            // 左端点从 l0 移动到 q.l
          	// 左端点起点在当前块的右端点，从右往左移
            for (int j = q.l; j < l0; j++) {
                add(min(dp2[j], r - j));
            }
            ans[q.qid] = sum;

            // 回滚：左端点回到当前块的右边界
          	// 对于大区间，左端点每次回到起点
            sum = tmp_sum;
        }
        // =========== 回滚莫队 模板结束
        
        return ans;
    }
};©leetcode
```





**【左闭右开】**

[3636. 查询超过阈值频率最高元素](https://leetcode.cn/problems/threshold-majority-queries/)

```cpp
/*
算法：
回滚莫队

时间复杂度： 
O(n * sqrt(q))

核心思想：
1. 把询问区间按照左端点所在块进行分组，左端点在同一个块的询问分到同一组；
2. 对于每个块，按照右端点排序，使得右端点一直向右移动，左端点只在块内抖动；
3. 这样，相邻询问间的交集能尽可能大，进而尽量减少增删元素的次数

假设将区间分成k个，每个区间的长度为B；
对于每个块，右端点的平均移动次数为 n/2；
对于所有询问，右端点的总移动次数为 nk/2 = n^2/2B；左端点的平均移动次数为 qB
所以，总移动次数为 n^2/2B + qB，由基本不等式可知，当 B = n / sqrt(2q) 时取到最小值，为保证B为正整数，实际可向上取整即ceil(n / sqrt(2q))

细节：
由于当我们考虑左端点的最大移动次数时，时间复杂度也在可接受范围内，所以对于每个询问，可以将左端点重置(更新到起始点，即当前块右端点)，这样就不用考虑删除了

*/


/*
算法：回滚莫队
时间复杂度： O(n * sqrt(q))

核心思想：
1. 把询问区间按照左端点所在块进行分组，左端点在同一个块的询问分到同一组；
2. 对于每个块，按照右端点排序，使得右端点一直向右移动，左端点只在块内抖动；
3. 这样，相邻询问间的交集能尽可能大，进而尽量减少增删元素的次数

假设将区间分成k个，每个区间的长度为B；
对于每个块，右端点的平均移动次数为 n/2；
对于所有询问，右端点的总移动次数为 nk/2 = n^2/2B；左端点的平均移动次数为 qB
所以，总移动次数为 n^2/2B + qB，由基本不等式可知，当 B = n / sqrt(2q) 时取到最小值，为保证B为正整数，实际可向上取整即ceil(n / sqrt(2q))

细节：由于当我们考虑左端点的最大移动次数时，时间复杂度也在可接受范围内，所以对于每个询问，可以将左端点重置(更新到起始点，即当前块右端点)，这样就不用考虑删除了

*/


struct Query {
    int bid; // 块id
    int l;
    int r;   // 左闭右开
    int threshold;
    int qid; // 询问id
    bool operator<(const auto& that) const {
        if (bid == that.bid) {
            return r < that.r;
        }
        return bid < that.bid;
    }
};


class Solution {
public:
    vector<int> subarrayMajority(vector<int>& a, vector<vector<int>>& qs) {
        int n = a.size(), m = qs.size();

        unordered_map<int, int> cnt;
        int max_cnt = 0, min_val = 0;
        auto add = [&](int x) {
            int c = ++cnt[x];
            if (c > max_cnt) {
                max_cnt = c;
                min_val = x;
            } else if (c == max_cnt) {
                min_val = min(min_val, x);
            }
        };
        vector<int> ans(m, -1);
        int block_size = ceil(n / sqrt(m * 2));

        vector<Query> pr;
        for (int i = 0; i < m; i++) {
            auto&q = qs[i];
            int l = q[0], r = q[1] + 1, threshold = q[2];
            // 大区间：离线
            if (r - l > block_size) {
                pr.emplace_back(l / block_size, l, r, threshold, i);
                continue;
            }
            // 小区间：暴力
            for (int j = l; j < r; j++) {
                add(a[j]);
            }
            if (max_cnt >= threshold) {
                ans[i] = min_val;
            }
          	// 注意：clear不要是O(m)的
            cnt.clear();
            max_cnt = 0;
        }

        sort(pr.begin(), pr.end());

        int r;
        for (int i = 0; i < pr.size(); i++) {
            auto& q = pr[i];
            // 右端点的起点 设置为当前块右边界的下一个点
            int l0 = (q.bid + 1) * block_size;
            // 遍历到新的块
            if (i == 0 || q.bid > pr[i - 1].bid) {
                r = l0;
                cnt.clear();
                max_cnt = 0;
            }

          	// 对于大区间
            // 右端点只能向右移动，从 r 移动到 q.r
            for (; r < q.r; r++) {
                add(a[r]);
            }
            int tmp_max_cnt = max_cnt;
            int tmp_min_val = min_val;

            // 左端点从 l0 移动到 q.l
          	// 左端点起点在当前块的右端点，从右往左移
            for (int j = q.l; j < l0; j++) {
                add(a[j]);
            }
            if (max_cnt >= q.threshold) {
                ans[q.qid] = min_val;
            }

            // 回滚：左端点回到当前块的右边界
          	// 对于大区间，左端点每次回到起点
            max_cnt = tmp_max_cnt;
            min_val = tmp_min_val;
            for (int j = q.l; j < l0; j++) {
                --cnt[a[j]];
            }
        }
        return ans;
    }
};
```





##### 5 summary

