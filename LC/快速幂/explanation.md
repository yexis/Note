#### 什么是快速幂算法？



- **取模的运算法则：**

```
(a + b) % p = (a % p + b % p) % p （1）

(a - b) % p = (a % p - b % p ) % p （2）

(a * b) % p = (a % p * b % p) % p （3）
```





- **计算 2的100次方的后三位**

```C++
//如果代码写成这样
//输出的结果是 0  为什么？
//因为2的100次方，早已超出了long long能承载的范围
//早已发生了溢出
long long normalPower(long long base,long long power){
    long long result=1;
    for(int i=1;i<=power;i++){
        result=result*base;
        result=result%1000;
    }
    return result%1000;
}
```



- **修改**

```C++
/**
 * 普通的求幂函数
 * @param base 底数
 * @param power  指数
 * @return  求幂结果的最后3位数表示的整数
 */
long long normalPower(long long base, long long power) {
    long long result = 1;
    for (int i = 1; i <= power; i++) {
        result = result * base;
        // 在每一步计算时，取后三位
        result = result % 1000;
    }
    return result % 1000;
}
```

虽然这个方法可行，但是考虑一下算法的时间复杂度：`O（n）`。如果要计算2的100次方，那么循环会执行100次。如果要计算2 的1000000000次方呢？这个程序会非常耗时。

---



所以，可以采用 3^10=3*3*3*3*3*3*3*3*3*3
3^10=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)
3^10=(3*3)^5
3^10=9^5
9^5=（9^4）*（9^1）
9^5=（9^4）*（9^1）
9^5=（6561^1）*(9^1)

[快速幂算法]: https://blog.csdn.net/qq_19782019/article/details/85621386



> 百度百科：
>
> 快速幂：就是快速算底数的n次幂，时间复杂度为O(logn)。相比朴素的O(n)做了极大的提高。
>
> 快速幂的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数不断变小，所需要执行的循环次数也会变小，而最后的结果却不会变化。



- **看一个简单例子**

```go
// 3^10=3*3*3*3*3*3*3*3*3*3
// 3^10=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)
// 3^10=(3*3)^5
// 3^10=9^5
// 9^5=（9^4）*（9^1）
// 9^5=（9^4）*（9^1）
// 9^5=（6561^1）*(9^1)
```

- **实现代码**

```C
// 1.常规情况
int power(int n, int b) {
    int res = 1;
    int x = n;
    while(x > 0) {
        if (b & 1) res *= x;
        x *= x;
        b >>= 1;
    }
}

// 2.考虑负数的情况 : 将负数转化成正数
int power(int n, int b) {
    int res = 1;
    int x = n;
    if (b < 0) {
        n = 1 / n;
        b = -b;
    }
    while(x > 0) {
        if (b & 1) res *= x;
        x *= x;
        b >>= 1;
    }
}

```



> Summary：可以看出在对指数 b进行二分的过程中，碰到奇数次幂，会把此时的底数x乘如 res中。
>
> 所以，快速幂法就是转化程成 计算 在二分的过程中的所有奇数次幂时的底数乘积。
>
> 这个算法可以使用二进制进行证明的。