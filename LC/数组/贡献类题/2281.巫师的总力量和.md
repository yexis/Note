### [2281. 巫师的总力量和](https://leetcode.cn/problems/sum-of-total-strength-of-wizards/)

##### emphasis

* 贡献类
* 单调栈
* 前缀和
* 前缀和的前缀和
* 公式推导

##### key points

* 下标从 $0$ 开始的整数数组 $nums$，$nums[i]$ 表示每个巫师的力量值
* 对于一组连续的巫师组，其总力量定下为以下两个值的**乘积** : 
  * 巫师中 **最弱** 的力量值
  * 巫师组中所有巫师的个人力量值 **之和**
* 答案可能会很大，将答案对$`10^9 + 7$ **取余** 后返回。

##### 思路

* 提示1 : **枚举每位巫师，假设他是最弱的巫师，那么他能在哪些子数组中**
  * 找出每一位巫师作为最小值时，子数组的左边界的最小值是多少？右边界的最大值是多少？
* 提示2 : **用单调栈来计算左右边界。**
  * 注意题目数组中是可能存在重复元素的，这会对答案造成什么影响？
  * 设左右边界为 $[L,R]$，为了避免重复计算，我们可以考虑左侧**严格小于**当前元素的最近的元素位置 $L - 1$，和右侧**小于等于**当前元素的最近元素位置 $R + 1$
  * 也就是说，为了避免重复统计，我们将左右两侧其中一个**严格小于改为小于等于**，就能避免重复。
  * 原理 : **造成重复统计的根本原因是子数组中最小值不唯一**，当存在多个最小元素时，每遍历一个最小元素，便会重复统计一次。
  * 如何让一个子数组的最值唯一？ok，给出如下定义 : 当元素 $nums[i]$ 和 $nums[j]$ 不相等时，按照元素值比较；当元素 $nums[i]$ 和 $nums[j]$ 的值相同时，按照下标 $i$ 和 $j$ 比较，即下标大的元素大
  * 其实实现起来就是将左侧的**严格小于**改成**小于等于**
  * 举个例子: 数组 $[1,3,1,2]$ ，如果左右两侧都是找严格小于，那么第一个 $1$ 和第二个 $1$ 算出来的边界范围都是一样的（都是整个数组），这就重复统计了，为了避免这种情况，可以把某一侧改为小于等于，比如**把左侧改成小于等于，那么第二个 $1$ 算出来的左边界不会触及或越过第一个 $1$，这样就能避免重复统计同一个子数组。**

* 提示3 :  设当前枚举的巫师的能力值是 $v$，那么他对答案产生的贡献是 $v$ 乘以左右边界 $[L,R]$内的所有包含 $v$ 的子数组的元素和的和
* 提示4 : 如何计算子数组的元素和  ----- **前缀和**
* 提示5 : 如果计算子数组和的和   ----- **前缀和的前缀和**（比较难想到，需要推导公式）

设子数组的左端点为 $l$，右端点为 $r$，当前枚举的下标为 $i$，那么有 $L\leq l\leq i \leq r \leq R$

设数组 $nums$ 的前缀和为 $s$，则
$$
s[i]=\sum_{j=0}^{i-1}nums[j]
$$
因此，子数组 $[l,r]$的元素和可以表示为
$$
s[r+1] - s[l]
$$
那么，在范围 $[L,R]$ 内的所有包含下标为 $i$ 的元素的子数组的**元素和的和**可以表示为
$$
\sum_{r=i+1}^{R+1}\sum_{l=L}^i(s[r]-s[l])
$$

$$
=(\sum_{r=i+1}^{R+1}\sum_{l=L}^i s[r])-(\sum_{r=i+1}^{R+1}\sum_{l=L}^i s[l])
$$

$$
=(i-L+1) \cdot \sum_{r=i+1}^{R+1}s[r] - (R - i + 1) \cdot \sum_{l=L}^i s[l]
$$

通过上式可以看出，我们需要计算前缀和 $s$ 的前缀和，定义为 $ss$，令
$$
ss[i] = \sum_{j=0}^{i-1}s[j]
$$
那么最终结果可以转化为下列式子
$$
(i-L+1) \cdot (ss[R+2] - ss[i + 1]) - (R - i + 1) \cdot (ss[i + 1] - ss[L])
$$
最后乘上 $v$ 即为当前巫师的贡献，累加所有贡献即可得到答案

##### 代码

```cpp
class Solution {
public:
    using ll = long long;
    const int mod = 1e9 + 7;

    int totalStrength(vector<int>& nums) {
        int n = nums.size();
        
        // 默认 : 当nums[i] = nums[j]时，比较i和j的大小，下标较大者，逻辑值较大
        vector<int> L(n, -1), R(n, n);
        
        // 这里也可以改成从两个方向运用两次单调栈
        stack<int> st;
        for (int i = 0; i < n; i++) {
            while (!st.empty() && nums[st.top()] > nums[i]) {
                R[st.top()] = i;
                st.pop();
            }
            if (!st.empty()) {
                L[i] = st.top();
            }
            st.push(i);
        }

        // 前缀和
        vector<ll> s(n + 1);
        for (int i = 0; i < n; i++) {
            s[i + 1] = (s[i] + nums[i]) % mod;
        }
      
        // 前缀和的前缀和
        vector<ll> ss(n + 2);
        for (int i = 0; i <= n; i++) {
            ss[i + 1] = (ss[i] + s[i]) % mod;
        }
        
        ll ans = 0;
        for (int i = 0; i < n; i++) {
            int l = L[i] + 1, r = R[i] - 1;
            ll x = (i - l + 1) * (ss[r + 2] - ss[i + 1]) % mod;
            ll y = (r - i + 1) * (ss[i + 1] - ss[l]) % mod;
            ans = (ans + (x - y) * nums[i]) % mod;
        }

        return (ans + mod) % mod;
    }
};
```

##### 注意

* 前缀和的数组大小是 $n+1$，前缀和的前缀和的数组大小是 $n+1+1$
* 注意求和公式的性质

##### 总结

* 贡献类的题，计算贡献时不能重复，即数组不可重复统计