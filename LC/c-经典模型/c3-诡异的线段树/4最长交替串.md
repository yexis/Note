### Title 最长交替串/最长交替子序列

##### 1 emphasis

- 最长交替子序列
- 懒加载线段树



##### 2 key points

 

##### 3 thought



##### 4 code

例题：[3777. 使子字符串变交替的最少删除次数](https://leetcode.cn/problems/minimum-deletions-to-make-alternating-substring/)

```cpp
using ll = long long;
const ll inf = 1e15;
struct Node {
    int c00; // 0开头0结尾的交替串最大长度
    int c01; // 0开头1结尾的交替串最大长度
    int c10; // 1开头0结尾的交替串最大长度
    int c11; // 1开头1结尾的交替串最大长度
    int z;
    Node() {
        c00 = c01 = c10 = c11 = z = 0;
    }
    Node(int a, int b, int c, int d) {
        c00 = a, c01 = b, c10 = c, c11 = d, z = 0;
    }
    // 取反
    void op() {
        swap(c00, c11);
        swap(c10, c01);
    }
};
// 重载
Node operator+(const Node& a, const Node& b) {
    Node res;
    res.c00 = max(a.c00, b.c00);
    res.c01 = max(a.c01, b.c01);
    res.c10 = max(a.c10, b.c10);
    res.c11 = max(a.c11, b.c11);

    auto cal = [&](int& x, int y, int z) -> void {
        if (y && z) x = max(x, y + z);
    };
    cal(res.c00, a.c00, b.c10);
    cal(res.c00, a.c01, b.c00);

    cal(res.c01, a.c00, b.c11);
    cal(res.c01, a.c01, b.c01);

    cal(res.c10, a.c10, b.c10);
    cal(res.c10, a.c11, b.c00);

    cal(res.c11, a.c10, b.c11);
    cal(res.c11, a.c11, b.c01);
    
    return res;
}

struct SegTree {
    constexpr static int N = 500000;
    vector<int> A;
    Node tr[N + 10]{};
    SegTree(vector<int>& a) {
        A = a;
    }

    void build(int o, int l, int r) {
        if (l == r) {
            if (A[l - 1] == 0) {
                tr[o] = Node(1, 0, 0, 0);
            } else {
                tr[o] = Node(0, 0, 0, 1);
            }
            return;
        }        
        int m = (l + r) >> 1;
        build(o * 2, l, m);
        build(o * 2 + 1, m + 1, r);
        push_up(o, l, r);
    }
    void push_up(int o, int l, int r) {
        tr[o] = tr[o * 2] + tr[o * 2 + 1];
    }
    void push_down(int o, int l, int r) {
        if (tr[o].z) {
            tr[o * 2].op();
            tr[o * 2].z ^= 1;
            tr[o * 2 + 1].op();
            tr[o * 2 + 1].z ^= 1;
            tr[o].z = 0;
        }
    }
    // 单点取反
    void add(int o, int l, int r, int i, int u) {
        if (l == r) {
            tr[o].op();
            return;
        }
        int m = (l + r) >> 1;
        if (i <= m) {
            add(o * 2, l, m, i, u);
        } else {
            add(o * 2 + 1, m + 1, r, i, u);
        }
        push_up(o, l, r);
    }
    // 区间取反
    void add_lr(int o, int l, int r, int L, int R, int u) {
        if (L <= l && R >= r) {
            tr[o].op();
            tr[o].z ^= 1;
            return;
        }
        if (tr[o].z) {
            push_down(o, l, r);
        }
        int m = (l + r) >> 1;
        if (L <= m) {
            add_lr(o * 2, l, m, L, R, u);
        } 
        if (R > m) {
            add_lr(o * 2 + 1, m + 1, r, L, R, u);
        }
        push_up(o, l, r);
    }

    // 看情况是否需要
    // 如果只询问全区间的最大字段和，使用tr[1]即可
    Node ask(int o, int l, int r, int L, int R) {
        if (L <= l && R >= r) {
            return tr[o];
        }
        if (tr[o].z) {
            push_down(o, l, r);
        }
        Node ans;
        int m = (l + r) >> 1;
        if (L <= m) {
            ans = ans + ask(o * 2, l, m, L, R);
        }
        if (R > m) {
            ans = ans + ask(o * 2 + 1, m + 1, r, L, R);
        }
        return ans;
    }
};
// 模板结束

class Solution {
public:  
    vector<int> minDeletions(string s, vector<vector<int>>& qs) {
        int n = s.size(), m = qs.size();
        vector<int> a(n);
        for (int i = 0; i < n; i++) if (s[i] == 'A') a[i] = 0; else a[i] = 1;
        vector<int> res;
        SegTree seg(a); seg.build(1, 1, n);
        for (auto& q : qs) {
            int op = q[0];
            if (op == 1) {
                int j = q[1];
                seg.add(1, 1, n, j + 1, 1);
            } else if (op == 2) {
                int l = q[1], r = q[2], len = (r - l + 1);
                Node ans = seg.ask(1, 1, n, l + 1, r + 1);
                res.push_back(len - max({ans.c00, ans.c01, ans.c10, ans.c11}));
            }
        }
        return res;
    }
};
```



##### 5 summary

