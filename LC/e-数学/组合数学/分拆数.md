### Title 分拆数

##### 1 emphasis



##### 2 key points

###### 2.1 分拆

将自然数$n$写成递降正整数和的表示。

$n = r_1 + r_2 + ... + r_k \ \ r_1 \ge r_2  \ge \ \ r_k \ge 1$

 

###### 2.2 分拆数 $p_n$

自然数$n$分拆方法数



###### 2.3 k部分拆数

将$n$分成恰有$k$个部分的分拆，称为$k$部分拆数，记作$p(n,k)$

$p(n,k)$等于以下方程的解数：

$n - k = x_1 + x_2 + ... + x_k \ \ x_1 \ge x_2 \ge ... \ge x_k \ge 1$

两边同时减$k$，则$p(n,k)$也等于以下方程的解数：

$n - k = y_1 + y_2 + ... + y_k \ \ y_1 \ge y_2 \ge ... \ge y_k \ge 0 \ \ \ \ ②$

对于$y_1,y_2,...,y_k$，其中可能存在$1,2,3,...,k$个非$0$数

故 方程$②$的解数可以表示为 $\sum_{j=1}^{k}P(n-k,j)$

所以 $p(n,k)=\sum_{j=1}^{k}P(n-k,j) \ \ \ ③$

同理$p(n-1,k-1)=\sum_{j=1}^{k-1}P(n-k,j) \ \ \ ④$

上述相邻两项作差，可得

$p(n,k) = p(n-1,k-1)+p(n-k,k)$

```cpp
// 分拆数: 自然数 n 的分拆方法数
// p(n,k) = p(n-1,k-1)+p(n-k,k)
ll p[10005][1005]; 
auto _ = []() -> int {
    cout << "here" << "\n";
    memset(p, 0, sizeof(p));
    p[0][0] = 1;
    for (int i = 1; i <= 10000; i++) {
        for (int k = 1; k <= 1000; k++) {
            if (i - k >= 0) {
                p[i][k] = p[i - 1][k - 1] + p[i - k][k];
                p[i][k] %= mod;
            }
        }
    }
    return 0;
}();
ll split_numbers(int n, int k) {
    return p[n][k];
}
void test_1() {
    for (int i = 1; i <= 10; i++) {
        for (int k = 1; k <= i; k++) {
            cout << i << " " << k << " " << p[i][k] << "\n";
        }
    }
}
```





###### 2.4 互异分拆数 $pd_n$

自然数$n$的各部分互不相同的分拆方法数

> 其他问法：
>
> 将数$n$拆分成$k$个不同（递增）（递减）的正整数的方案数

同样使用方程的解数来表示$pd(n,k)$

$n = x_1+x_2+...+x_k  \ \ \ \ x_1 > x_2 > ... > x_k > 0$

令$y = x-1$，则

$n = y_1+y_2+...+y_k  \ \ \ \ y_1 > y_2 > ... > y_k > 0$

观察$y_1 > y_2 > ... > y_k > 0$，不难发现，仅$y_k$可能取$0$

故 $pd(n,k)=\sum_{j=k-1}^{k}pd(n-k,j)$

$pd(n,k) = pd(n - k, k - 1) + pd(n - k, k)$

```cpp
// 互异分拆数: 自然数 n 的各部分互不相同的分拆方法数
// pd(n,k) = pd(n - k, k - 1) + pd(n - k, k)
ll pd[100005][355];
auto __ = []() -> int {
    memset(pd, 0, sizeof(pd));
    pd[0][0] = 1;
    for (int i = 1; i <= 100000; i++) {
        for (int k = 1; k <= 350; k++) {
            if (i - k >= 0) {
                pd[i][k] = pd[i - k][k - 1] + pd[i - k][k];
                pd[i][k] %= mod;
            }
        }
    }
    return 0;
}();
ll split_numbers_different(int n, int k) {
    return pd[n][k];
}
void test_2() {
    for (int i = 1; i < 10; i++) {
        for (int k = 1; k < i; k++) {
            cout << i << " " << k << " " << pd[i][k] << "\n";
        }
    }
}
```





##### 3 thought



##### 4 code



##### 5 summary

