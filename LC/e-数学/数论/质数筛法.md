## 一 质数个数

> - 质数个数
> - 10的5次方以内的质数
> - 10的6次方以内的质数
> - 10的7次方以内的质数

### 1.1 范围内质数个数

| 范围    | 质数个数 |
| ------- | -------- |
| $10^ 2$ | 25       |
| $10^3$  | 168      |
| $10^4$  | 1229     |
| $10^5$  | 9592     |
| $10^6$  | 78498    |
| $10^7$  | 664579   |
| $10^8$  | 5761455  |
| $10^9$  | 50847534 |

### 1.2 1000以内的质数

```cpp
{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997}
```







## 质数筛法

> - 素数筛法
>
> - 质数筛法
> - 输出所有质数
> - 埃氏筛
> - 埃氏筛法
> - 线性筛
> - 线性筛法



### 埃拉托斯特尼筛法（埃氏筛）

> 时间复杂度：$O(n*log(log(n)))$

```cpp
const int N = 1e6;
bool is_prime[N + 1];
vector<int> prime;

void init() {
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= N; ++i) is_prime[i] = true;
    for (int i = 2; i <= N; ++i) {
        if (is_prime[i]) {
            prime.push_back(i);
            if ((long long)i * i > N) continue;
            for (int j = i * i; j <= N; j += i)
                // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i
                // 的倍数开始，提高了运行速度
                is_prime[j] = false;  // 是 i 的倍数的均不是素数
        }
    }
}
```



##### 写法二

> 时间复杂度：$O(n*log(log(sqrt(n))))$

```cpp
const int N = 1e6;
bool is_prime[N + 1];
vector<int> prime;

void init() {
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= N; ++i) is_prime[i] = true;
    // i * i <= n 说明 i <= sqrt(n)
    for (int i = 2; i * i <= N; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= N; j += i) {
                is_prime[j] = false;       
            }
        }
    }
    for (int i = 2; i <= N; ++i) {
        if (is_prime[i]) {
            prime.push_back(i);
        }
    }
}
```





### 欧拉筛法（线性筛法）

> 时间复杂度：$O(n)$
>
> 在线性筛中，每个合数$m$都是被**最小的质因子**筛掉的

```cpp
const int N = 1e6;
vector<int> prime;
bool not_prime[N + 1];

void init() {
    for (int i = 2; i <= N; ++i) {
        if (!not_prime[i]) {
            prime.push_back(i);
        }
        for (int p : prime) {
            if (i * p > N) break;
            not_prime[i * p] = true;
            if (i % p == 0) {
                // i % p == 0
                // 换言之，i 之前被 p 筛过了
                // 由于 prime 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被 p 的某个倍数筛掉
                // 就不需要在这里先筛一次，所以这里直接 break 掉就好了
                break;
            }
        }
    }
}
```

