### 裴蜀定理

1. 对于不全为零的任意整数 $a$ 和 $b$，记$g=gcd(a,b)$，其中 $gcd(a,b)$ 为 $a$ 和 $b$ 的最大公约数，则对于任意整数 $x$ 和 $y$ 都满足 $a \times x + b \times y$ 是 $g$ 的倍数，特别地，存在整数 $x$ 和 $y$ 满足$a \times x + b \times y = g$ 

   

2. 裴蜀定理也可以推广到多个整数的情况，对于不全为零的任意n个整数 $a_1,a_2,...a_n$，记这n个数的最大公约数为 $g$，则对于任意 $n$ 个整数 $x_1,x_2,...,x_n$ 都满足 $\sum_{i=1}^na_i\times x_i$ 是 $g$ 的倍数。**一个重要的推论是: 正整数 $a_1$ 到 $a_n$ 的最大公约数是1的充分必要条件是存在 $n$ 个整数 $x_1$ 到 $x_n$ 满足 $\sum_{i=1}^na_i\times x_i = 1$**



### 应用

##### 场景1 

比如在一个长度为 $n$ 的数组上，存在一个移动的点，该点从起点0开始，每次向右移动b个单位距离，当超出n之后，继续循环从头开始计数，直到回到原始位置，问： 如何枚举该点达到过的位置

* 方法一: 简单粗暴的方法

```cpp
vector<int> vis(n);
for (int i = 0; vis[i] == 0; i = (i + b) % n) {
  // do something
}
```

* 方法二: 裴蜀定理

  该点到达的位置有 $(0 * b) \ mod \ n, (1 * b) \ mod \ n, (2 * b) \ mod \ n,...,(x * b) \ mod \ n$

  假如该点到答的点用 $z$ 表示，也就是说，$(x * b) \ mod \ n = z$，即$x * b + y * n = z$

  那么，根据裴蜀定理，$z$ 一定是$gcd(b,n)$的倍数

```cpp
int g = gcd(b, n);
for (int i = 0; i < n; i += g) {
  // do something
}
```

