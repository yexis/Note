### 一 区间求和  单点更新 + 区间查询  

```cpp
// o : 当前树节点的下标
// l : 当前树节点代表的区间左端点
// r : 当前树节点代表的区间右端点
// i : 需要更新的数组下标
// u : 需要更新的值
// L : 查询的数组区间的左端点
// R : 查询的数组区间的右端点

// 线段树数组
int a[1000];
// 原数组
int f[4001];

void build(int o, int l, int r) {
    if (l == r) {
        f[o] = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(o * 2, l , m);
    build(o * 2 + 1, m + 1, r);
    f[o] = f[o * 2] + f[o * 2 + 1];
}

// build 可以使用 add 代替
void add(int o, int l, int r, int i, int u) {
    if (l == r) {
        f[o] += u;
        return;
    }
    int m = (l + r) >> 1;
    if (i <= m) {
        add(o * 2, l, m, i ,u);
    } else {
        add(o * 2 + 1, m + 1, r, i, u);
    }
    f[o] = f[o * 2] + f[o * 2 + 1];
}

int ask(int o, int l, int r, int L, int R) {
    if (L <= l && R >= r) {
        return f[o];
    }
    int ans = 0;
    int m = (l + r) >> 1;
    if (L <= m) {
        ans += ask(o * 2, l, m, L, R);
    }
    if (R > m) {
        ans += ask(o * 2 + 1, m + 1, r, L, R);
    }
    return ans;
}

```



### 二 求最值 单点更新+区间求和

```cpp
// 线段树
int f[40001];
// 原数组
int a[10000];

void add(int o, int l, int r, int i, int u) {
    if (l == r) {
        f[o] = u;
        return;
    }
    int m = (l + r) >> 1;
    if (i <= m) {
        add(o * 2, l, m, i, u);
    } else {
        add(o * 2 + 1, m + 1, r, i, u);
    }
    f[o] = max(f[o * 2], f[o * 2 + 1]);
}

int ask(int o, int l, int r, int L, int R) {
    if (L <= l && R >= r) {
        return f[o];
    }

    int ans = 0;
    int m = (l + r) >> 1;
    if (L <= m) {
        ans = max(ans, ask(o * 2, l, m, L, R));
    }
    if (R > m) {
        ans = max(ans, ask(o * 2 + 1, m + 1, r, L, R));
    }
    return ans;
}
```



### 三 区间加    lazy懒加载机制

```cpp
namespace SEG_INTERVAL_1 {
    int f[40010];
    int z[40010];
    void init() {
        memset(f, 0, sizeof(f));
        memset(z, 0, sizeof(z));
    }
    void add(int o, int l, int r, int L, int R, int u) {
        if (L <= l && R >= r) {
            f[o] += (r - l + 1) * u;
            z[o] += u;
            return;
        }
        int m = (l + r) >> 1;
        if (z[o]) {
            f[o * 2] += (m - l + 1) * z[o];
            f[o * 2 + 1] += (r - m) * z[o];
            z[o * 2] += z[o];
            z[o * 2 + 1] +=  z[o];
            z[o] = 0;
        }
        if (L <= m) {
            add(o * 2, l, m, L, R, u);
        }
        if (R > m) {
            add(o * 2 + 1, m + 1, r, L, R, u);
        }
        f[o] = f[o * 2] + f[o * 2 + 1];
    }
    int ask(int o, int l, int r, int L, int R) {
        if (L <= l && R >= r) {
            return f[o];
        }
        int m = (l + r) >> 1;
        if (z[o]) {
            f[o * 2] += (m - l + 1) * z[o];
            f[o * 2 + 1] += (r - m) * z[o];
            z[o * 2] += z[o];
            z[o * 2 + 1] +=  z[o];
            z[o] = 0;
        }
        int ans = 0;
        if (L <= m) {
            ans += ask(o * 2, l, m, L, R);
        }
        if (R > m) {
            ans += ask(o * 2 + 1, m + 1, r, L, R);
        }
        return ans;
    }
}
```



### 四 区间改    lazy懒加载机制

```cpp
namespace SEG_INTERVAL_TO_1 {
    int f[400010];
    int z[400010];
    void init() {
        memset(f, 0, sizeof(f));
        memset(z, 0, sizeof(z));
    }
    void add(int o, int l, int r, int L, int R, int u) {
        if (L <= l && R >= r) {
            f[o] = (r - l + 1) * u;
            z[o] = u;
            return;
        }
        int m = (l + r) >> 1;
      	// 标记下推
      	// 孩子节点是=，而不是+
        if (z[o]) {
            f[o * 2] = (m - l + 1) * z[o];
            f[o * 2 + 1] = (r - m) * z[o];
            z[o * 2] = z[o];
            z[o * 2 + 1] = z[o];
            z[o] = 0;
        }
        if (L <= m) {
            add(o * 2, l, m, L, R, u);
        }
        if (R > m) {
            add(o * 2 + 1, m + 1, r, L, R, u);
        }
        f[o] = f[o * 2] + f[o * 2 + 1];
    }
    int ask(int o, int l, int r, int L, int R) {
        if (L <= l && R >= r) {
            return f[o];
        }
        int m = (l + r) >> 1;
        if (z[o]) {
            f[o * 2] = (m - l + 1) * z[o];
            f[o * 2 + 1] = (r - m) * z[o];
            z[o * 2] = z[o];
            z[o * 2 + 1] = z[o];
            z[o] = 0;
        }
        int ans = 0;
        if (L <= m) {
            ans += ask(o * 2, l, m, L, R);
        }
        if (R > m) {
            ans +=  ask(o * 2 + 1, m + 1, r, L, R);
        }
        return ans;
    }
}
```



### 五 区间最值

```cpp
// add: 直接设置成u

// add: 比较后设置成u
```





### 六 区间异或    lazy懒加载机制

* 注意: 区间异或时，等于把区间里的 $0$ 变成 $1$，$1$ 变成 $0$，故区间和关于区间长度求反即可 `f[o] = (r - l + 1) - f[o];`

```cpp
// 异或
namespace SEG_INTERVAL_OR_1 {
    // 线段树数组
    int f[400010];
    // 懒标记数组
    int z[400010];
    void init() {
        memset(f, 0, sizeof(f));
        memset(z, 0, sizeof(z));
    }
    void add(int o, int l, int r, int L, int R) {
        if (L <= l && R >= r) {
            f[o] = (r - l + 1) - f[o];
            z[o] ^= 1;
            return;
        }
        int m = (l + r) >> 1;
        // 标记下推
        if (z[o]) {
            f[o * 2] = (m - l + 1) - f[o * 2];
            f[o * 2 + 1] = (r - m) - f[o * 2 + 1];
            z[o * 2] ^= 1;
            z[o * 2 + 1] ^= 1;
            z[o] = 0;
        }
        if (L <= m) {
            add(o * 2, l, m, L, R);
        }
        if (R > m) {
            add(o * 2 + 1, m + 1, r, L, R);
        }
        f[o] = f[o * 2] + f[o * 2 + 1];
    }
    int ask(int o, int l, int r, int L, int R) {
        if (L <= l && R >= r) {
            return f[o];
        }
        int m = (l + r) >> 1;
        // 标记下推
        if (z[o]) {
            f[o * 2] = (m - l + 1) - f[o * 2];
            f[o * 2 + 1] = (r - m) - f[o * 2 + 1];
            z[o * 2] ^= 1;
            z[o * 2 + 1] ^= 1;
            z[o] = 0;
        }
        int ans = 0;
        if (L <= m) {
            ans += ask(o * 2, l, m, L, R);
        }
        if (R > m) {
            ans += ask(o * 2 + 1, m + 1, r, L, R);
        }
        return ans;
    }
}

```



### 七 组合线段树 「统计区间的平方和」

支持操作：

1. 区间修改 「如：区间同时+1」
2. 区间统计 「如：统计区间[l,r]的所有元素的平方和」



原理：

$(x+1)^2=x^2+2x+1$

所以，从$x^2\rightarrow (x+1)^2$，必须要经过$+2x+1$

所以线段树，不仅要存区间平方和，还要存区间和

```cpp
using ll = long long;
const int mod = 1e9 + 7;

namespace SEG_INTERVAL_ADD_X2_1 {
    ll f[400010]; // 区间和
    ll g[400010]; // 平方和
    ll z[400010];
    void init() {
        memset(f, 0, sizeof(f));
        memset(g, 0, sizeof(g));
        memset(z, 0, sizeof(z));
    }
    void add(int o, int l, int r, int L, int R, int u) {
        if (L <= l && R >= r) {
            g[o] += 2 * u * f[o] + (r - l + 1) * u * u;
            g[o] %= mod;
            f[o] += (r - l + 1) * u;
            f[o] %= mod;
            z[o] += u;
            z[o] %= mod;
            return;
        }
        int m = (l + r) >> 1;
        if (z[o]) {
            g[o * 2] += 2 * z[o] * f[o * 2] + (m - l + 1) * z[o] * z[o];
            g[o * 2] %= mod;
            g[o * 2 + 1] += 2 * z[o] * f[o * 2 + 1] + (r - m) * z[o] * z[o];
            g[o * 2 + 1] %= mod;
            f[o * 2] += (m - l + 1) * z[o];
            f[o * 2] %= mod;
            f[o * 2 + 1] += (r - m) * z[o];
            g[o * 2] %= mod;
            z[o * 2] += z[o];
            z[o * 2] %= mod;
            z[o * 2 + 1] += z[o];
            z[o * 2 + 1] %= mod;

            z[o] = 0;
        }
        if (L <= m) {
            add(o * 2, l, m, L, R, u);
        }
        if (R > m) {
            add(o * 2 + 1, m + 1, r, L, R, u);
        }
        f[o] = f[o * 2] + f[o * 2 + 1];
        f[o] %= mod;
        g[o] = g[o * 2] + g[o * 2 + 1];
        g[o] %= mod;
    }

    int ask(int o, int l, int r, int L, int R) {
        if (L <= l && R >= r) {
            return g[o];
        }
        int m = (l + r) >> 1;
        if (z[o]) {
            g[o * 2] += 2 * z[o] * f[o * 2] + (m - l + 1) * z[o] * z[o];
            g[o * 2] %= mod;
            g[o * 2 + 1] += 2 * z[o] * f[o * 2 + 1] + (r - m) * z[o] * z[o];
            g[o * 2 + 1] %= mod;
            f[o * 2] += (m - l + 1) * z[o];
            f[o * 2] %= mod;
            f[o * 2 + 1] += (r - m) * z[o];
            f[o * 2 + 1] %= mod;
            z[o * 2] += z[o];
            z[o * 2] %= mod;
            z[o * 2 + 1] += z[o];
            z[o * 2 + 1] %= mod;
            z[o] = 0;
        }
        int ans = 0;
        if (L <= m) {
            ans += ask(o * 2, l, m, L, R);
            ans %= mod;
        }
        if (R > m) {
            ans += ask(o * 2 + 1, m + 1, r, L, R);
            ans %= mod;
        }
        return ans;
    }
};
```



### 八 组合线段树 「统计区间的立方和」

待续。。。



### 九 摩尔投票线段树 「单点修改，区间查询」

```cpp
// 摩尔投票的线段树
// 基于pair<int, int> 的实现
typedef pair<int, int> pii;
pii operator+(const pii& a, const pii& b) {
    pii res = a;
    if (a.first == b.first) {
        res.second = a.second + b.second;
    } else if (a.second >= b.second) {
        res.second = a.second - b.second;
    } else {
        res.first = b.first;
        res.second = b.second - a.second;
    }
    return res;
};

pii f[80010];
void init() {
    for (int i = 0; i < 80010; i++) {
        f[i] = pii();
    } 
}
void add(int o, int l, int r, int i, int u) {
    if (l == r) {
        f[o] = pii(u, 1);
        return;
    }
    int m = (l + r) >> 1;
    if (i <= m) {
        add(o * 2, l, m, i, u);
    } else {
        add(o * 2 + 1, m + 1, r, i, u);
    } 
    f[o] = f[o * 2] + f[o * 2 + 1];
}

pii ask(int o, int l, int r, int L, int R) {
    if (L <= l && R >= r) {
        return f[o];
    }
    pii ans;
    int m = (l + r) >> 1;
    if (L <= m) {
        ans = ans + ask(o * 2, l, m, L, R);
    }
    if (R > m) {
        ans = ans + ask(o * 2 + 1, m + 1, r, L, R);
    }
    return ans;
}
```



