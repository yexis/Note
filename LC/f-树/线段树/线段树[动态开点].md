### Title 动态开点线段树

##### 1 emphasis

- 线段树
- 动态开点
- 动态开点线段树



##### 2 key points

 

##### 3 thought



##### 4 code

> 单点加，区间和  [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

```cpp
using ll = long long;
constexpr static int N = 4e5 + 10;
struct DynamicSegTree {
    int tot;
    ll tr[N];
    int lc[N], rc[N];
  	// 初始化
    DynamicSegTree() {
        tot = 0;
        memset(tr, 0, sizeof tr);
        memset(lc, 0, sizeof(lc));
        memset(rc, 0, sizeof(rc));
    }
    void add(int& o, int l, int r, int i, int u) {
        if (!o) o = ++tot;
        if (l == r) {
            tr[o] += u;
            return;
        }
        int m = (l + r) >> 1;
        if (i <= m) {
            add(lc[o], l, m, i, u);
        } else {
            add(rc[o], m + 1, r, i, u);
        }
        tr[o] = tr[lc[o]] + tr[rc[o]];
    }

    ll ask(int o, int l, int r, int L, int R) {
        if (!o) return 0;
        if (L <= l && R >= r) {
            return tr[o];
        }
        ll ans = 0;
        int m = (l + r) >> 1;
        if (L <= m) {
            ans += ask(lc[o], l, m, L, R);
        }
        if (R > m) {
            ans += ask(rc[o], m + 1, r, L, R);
        }
        return ans;
    }
};


class Solution {
public:
    vector<int> countSmaller(vector<int>& a) {
        int n = a.size();
        DynamicSegTree seg;

        auto off = [&](int x) -> int {
            return x + 10000;
        };

        // 树根，一定要定义，因为传的是引用
        int root = 0;
        const int N = 1e9;
        vector<int> res(n);
        for (int i = n - 1; i >= 0; i--) {
            int x = off(a[i]);
            if (x > 0) {
                res[i] = seg.ask(root, 1, N, 1, x);
            }
            seg.add(root, 1, N, x + 1, 1);
        }

        return res;
    }
};
```



##### 5 summary

