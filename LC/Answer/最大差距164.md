



---

写在前面

由于题目限制，要求线性时间复杂度和空间复杂度，所以如果直接对原数组进行排序是不满足要求的，因为排序算法的最小时间复杂度都是O(nlogn)。要在常数级别的时间复杂度内计算出该问题，那么时间复杂度只能控制在`O(n)`。



#### 思路: 计数排序

明显，常规的排序算法肯定是不行的，我们可以**考虑空间换时间的做法**。

找出数组`nums`中的最大值`MAX`，使用`MAX`作为size来创建一个数组`A`，`A`数组用来存储元素`v`是否在`nums`中出现过，例如：如果`v`在数组`nums`中出现过，则将A数组中v下标的位置置为1，`A[v]=1`，否则`A[v] = 0`。

当然，数组A不管是使用整型int或者bool都是可以的，只要能标识元素是否出现过即可。

最后，遍历数组A，计算所有相邻的元素为1的位置的下标差值。

例子: 

```go
/*
假如 nums = [1, 3, 4, 8, 10]
最大值MAX = 10,所以需要申请一个大小为11的数组
A := make([]int, 10)
将以nums中的元素为下标的位置分别置为1
A[1] = 1
A[3] = 1
A[4] = 1
A[8] = 1
A[10] = 1
所以， 最后计算的最大差距是8 - 4 = 4 
*/
```

#### 不足：对于困难的题要想通过哪有那么简单

不足也很明显，内存消耗太大。题目中说了nums中元素的范围在32位非负整数范围内，也就是说最大值可能是2 ^32 -1。申请如此大的数组，可能吗？显然不可能。

不出所料，当nums的最大值稍微大点，内存便超限了！！！

**总结一下，该算法的不足有两点：**

1. 需要申请的数组太大
2. 内存浪费，如果数组中的元素跨度太大，将造成许多内存的浪费。

如果解决以上两个问题，该题应该也就解



#### 优化：使用bit数组

用一个int类型（32bit/4字节）来保存一个只存在2种状态的值，仿佛是太过浪费了些。

退一步就算使用bool类型（8bit/1字节）来保存，那也浪费了剩下的7bit。



所以，可以考虑使用bit数组进行保存，只用1 bit来保存一个值，该值有两个状态（0和1），这样也就解决了数组内存消耗太大的问题。

也就是说，一个int型有32bit，可以存32个数的状态; 一个int64）类型有64bit，可以存放64个数的状态。这里我们选择int64类型。

> 说明： 
>
> int64是golang为了简洁语法创造的64位整型类型。
>
> C++或者java，对应int64的数据类型是long long 



**步骤：**

1. 遍历数组`nums`,计算数组中的最大值MAX
2. 使用` l = MAX / 64`计算所需要申请的数组的大小（注意：如果`MAX % 64 != 0`,则`l`需要加1）。一个int64数组有64位，所以可以保存64个值
3. 下面就应该遍历数组`nums`，然后分别进行保存（如果v存在，那么就将v对应的位置置为 1） 
4. 那么怎样计算数值`v`在数组中的位置呢？ 先用`v / 64` 计算出数组的下标，然后通过 `v % 64`计算`v`的位置对应int中的偏移量。
5. 最后将该位置置为 1

**例子：**

```go
// nums = [10000000, 1,65,100,2,3,4]
// MAX = 10000000
// 最大值为10000000,那么A数组的大小需要多大?  l = 10000000 / 64 + 1 = 156251
// 然后分别计算各个元素在数组 A 中的 下标 和 偏移量
// 1        : 1/64 = 0                 1 % 64 = 1         所以 1 的位置在 A[0] 的第 1 位 ,将该位 置为1 即可
// 2        : 2/64 = 0                 2 % 64 = 2         所以 2 的位置在 A[0] 的第 2 位 ,将该位 置为1 即可
// 2        : 3/64 = 0                 3 % 64 = 3         所以 3 的位置在 A[0] 的第 3 位 ,将该位 置为1 即可
// 2        : 4/64 = 0                 4 % 64 = 4         所以 4 的位置在 A[0] 的第 4 位 ,将该位 置为1 即可
// 65       : 65/64 = 1                65 % 64 = 1        所以 65 的位置在 A[1] 的第 1 位 ,将该位 置为1 即可
// 100      : 100/64 = 1               100 % 64 = 36      所以 100 的位置在 A[1] 的第 36 位 ,将该位 置为1 即可
// 10000000 : 10000000/64 = 156250     10000000 % 64 = 0  所以 10000000 的位置在 A[156250] 的第 0 位 ,将该位 置为1 即可


// 最后，遍历数组 A， 如果A[i] == 0 直接跳过，如果 A[i] != 0,判断A[i]哪些位置为1， 计算出距离的最大值
```

> 说明： 使用bit数组来存储，一般采用 按 1 左移 的方法， 即 `1 << n`



#### 代码：

```go
func maximumGap(nums []int) int {
	if len(nums) < 2 {
		return 0
	}

	var MAX int
	for _, v := range nums {
		if v > MAX {
			MAX = v
		}
	}

	l := 1
	for l < MAX {
		l <<= 1
	}
	if (l & 63) != 0 {
		l = (l >> 6) + 1
	} else {
		l >>= 6
	}

	A := make([]int64, l + 1)
	for _, v := range nums {
		q := v>>6
		r := v&63
		A[q] |= 1<<r
	}

	res := 0
	last := -1 // 记录上一个i的位置
	for i := 0; i < l; i++ {
		if A[i] == 0 {
			continue
		}
		for j := 0; j < 64; j++ {
			if (A[i]&(1<<j)) == 0 {
				continue
			}
			v := i * 64 + j
			if last == -1 {
				last = v
				continue
			}
			if v - last >= res {
				res = v - last
			}
			last = v
		}
	}
	return res
}
```



#### 写在最后：

虽然代码比较简单，但是对于数组中元素跨度较大的案例，还是比较浪费内存的。所以该方法仅适合比较稠密的数组，并不适合稀疏的数组。

至于复杂度，也不知道能不能算作常数级别， 取决于 nums中的最大值 MAX.

不过至少是按照自己的思路完成的，写个记录供大家参考。