### T4 [3762. 使数组元素相等的最小操作次数](https://leetcode.cn/problems/minimum-operations-to-equalize-subarrays/)

##### 1 emphasis

- 主席树
- 可持久化线段树
-  中位数贪心



##### 2 key points



##### 3 thought



##### 4 code

```cpp
using ll = long long;
static constexpr int maxn = 100010;
struct RMQMAX {
    int Log;
    int n;
    vector<vector<int>> st;
    // 采用vector<RMQ>时，可以将其改造成init方法
    RMQMAX(vector<int>& ob) {
        n = ob.size();
        // Log 存储n以内最大的二次幂指数，实在不行可以设置成最大 32
        Log = 32 - __builtin_clz(n);
        // 这里一定不能使用resize，resize不会更新已有范围
        st.assign(n, vector<int>(Log, -1));
        for (int i = 0; i < n; i++) {
            st[i][0] = ob[i];
        }

        for (int d = 1;  d < Log; d++) {
            for (int i = 0; i + (1 << (d - 1)) < n; i++) {
                st[i][d] = max(st[i][d - 1], st[i + (1 << (d - 1))][d - 1]);
            }
        }
    }

    ll ask(int l, int r) {
        if (l > r) {
            return -1;
        }
        int d = 31 - __builtin_clz(r - l + 1);
        return max(st[l][d], st[r - (1 << d) + 1][d]);
    }
};

struct RMQMIN {
    int Log;
    int n;
    vector<vector<int>> st;
    // 采用vector<RMQ>时，可以将其改造成init方法
    RMQMIN(vector<int>& ob) {
        n = ob.size();
        // Log 存储n以内最大的二次幂指数，实在不行可以设置成最大 32
        Log = 32 - __builtin_clz(n);
        // 这里一定不能使用resize，resize不会更新已有范围
        st.assign(n, vector<int>(Log, -1));
        for (int i = 0; i < n; i++) {
            st[i][0] = ob[i];
        }

        for (int d = 1;  d < Log; d++) {
            for (int i = 0; i + (1 << (d - 1)) < n; i++) {
                st[i][d] = min(st[i][d - 1], st[i + (1 << (d - 1))][d - 1]);
            }
        }
    }

    ll ask(int l, int r) {
        if (l > r) {
            return -1;
        }
        int d = 31 - __builtin_clz(r - l + 1);
        return min(st[l][d], st[r - (1 << d) + 1][d]);
    }
};

class Solution {
public:
    /*
     * 主席树
     * 可持久化线段树
     * 静态主席树
    */
    using ll = long long;
    using pll = pair<ll, ll>;
    static constexpr int N = 7e5;
    int root[N + 10];
    // 全局编号
    int tot;
    struct Node {
        int left, right;
        int val; // 只加1，表示区间原数数量
        ll val2; // 可加x，表示区间和
        Node() {left = right = val = val2 = 0;}
        Node(int _left, int _right, int _val, ll _val2) : left(_left), right(_right), val(_val), val2(_val2) {};
        Node operator+(const Node& a) const {
            Node res;
            res.val = val + a.val;
            res.val2 = val2 + a.val2;
            return res;
        }
    } seg[N + 10]{};
    
    
    void init() {
        tot = 0;
        for (int i = 0; i <= N; i++) {
            root[i] = 0;
            seg[i].left = seg[i].right = seg[i].val = seg[i].val2 = 0;
        }
    }
    /*
     * pre: 上一个版本的线段树
     * now: 当前版本的线段树
     * l: 节点所表示的区间左端点
     * r:节点所表示的区间右端点
     * tot: 操作的位置 
     * val: 变化量
     */
    void add(int pre, int& now, int l, int r, int pos, int val, int val2) {
        if (!now) {
            now = ++tot;
        }
        if (l == r) {
            seg[now].val = seg[pre].val + val;
            seg[now].val2 = seg[pre].val2 + val2;
            return;
        }
        int mid = (l + r) >> 1;
        if (pos <= mid) {
            seg[now].right = seg[pre].right;
            add(seg[pre].left, seg[now].left, l, mid, pos, val, val2);
        } else {
            seg[now].left = seg[pre].left;
            add(seg[pre].right, seg[now].right, mid + 1, r, pos, val, val2);
        }
        seg[now].val = seg[seg[now].left].val + seg[seg[now].right].val;
        seg[now].val2 = seg[seg[now].left].val2 + seg[seg[now].right].val2;
    }
    
    /*
     * 计算 [版本pre, 版本now]的线段树上 区间[l, r]中 的第k小的值
     * 由于一般为权值线段树，所以这里的[l,r]一般都是[1,n]
     * 
     * pre: 上一个版本的线段树的根节点
     * now: 当前版本的线段树的根节点
     * l: 节点所表示的区间左端点
     * r: 节点所表示的区间右端点
     * k: 询问第k大的值
     */
    int ask_k_min(int pre, int now, int o, int l, int r, int k) {
        if (l == r) {
            return l;
        }
        int mid = (l + r) >> 1;
        // 判断左孩子的元素数量是否大于k，这里等于二分，因为线段树的父节点的两个孩子是均分的
        int sum = seg[seg[now].left].val - seg[seg[pre].left].val;
        if (k <= sum) {
            return ask_k_min(seg[pre].left, seg[now].left, o * 2, l, mid, k);
        } else {
            return ask_k_min(seg[pre].right, seg[now].right, o * 2 + 1, mid + 1, r, k - sum);
        }
    }

    /*
     * 计算区间 [l,r] 中的第k小的值
     * 这里把 pre 和 now 分开计算，外层直接相减即可
     * 
     * now: 当前版本的线段树的根节点
     * l: 节点所表示的区间左端点
     * r: 节点所表示的区间右端点
     * k: 询问 now版本的线段树上 第k小的值，
     */
    Node ask_sum(int now, int o, int l, int r, int L, int R) {
        if (L <= l && R >= r) {
            return Node(0, 0, seg[now].val, seg[now].val2);
        }
        Node ans;
        int m = (l + r) >> 1;
        if (L <= m) {
            ans = ans + ask_sum(seg[now].left, o * 2, l, m, L, R);
        }
        if (R > m) {
            ans = ans + ask_sum(seg[now].right, o * 2 + 1, m + 1, r, L, R);
        }
        return ans;
    }

    /*
     * 计算 [版本pre, 版本now] 的线段树上 区间 [l,r] 中的第k小的值
     * 这里把 pre 和 now 一起
     * 这个版本其实就是ask_sum的基础上，加入一个[pre,now]的差分
     * 
     * pre: 上一个版本的线段树的根节点
     * now: 当前版本的线段树的根节点
     * l: 节点所表示的区间左端点
     * r: 节点所表示的区间右端点
     * k: 询问 [pre, now] 版本的线段树上 第k小的值
     */
    Node ask_sum_pre_now(int pre, int now, int o, int l, int r, int L, int R) {
        if (L <= l && R >= r) {
            Node ans;
            ans.val = seg[now].val - seg[pre].val;
            ans.val2 = seg[now].val2 - seg[pre].val2;
            return ans;
        }
        Node ans;
        int m = (l + r) >> 1;
        if (L <= m) {
            ans = ans + ask_sum_pre_now(seg[pre].left, seg[now].left, o * 2, l, m, L, R);
        }
        if (R > m) {
            ans = ans + ask_sum_pre_now(seg[pre].right, seg[now].right, o * 2 + 1, m + 1, r, L, R);
        }
        return ans;
        
    }
    // 以上是主席树模板


    vector<long long> minOperations(vector<int>& a, int K, vector<vector<int>>& qs) {
        int n = a.size(), m = qs.size();
        // 1. 同余
        // 2. 动态区间中位数（主席树）
        // 3. 中位数贪心
        // 4. 区间[l, r]中大于mid的和，小于mid的和

        vector<ll> sum(n + 1); for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + a[i];
    
        vector<int> R(n); for (int i = 0; i < n; i++) R[i] = a[i] % K;   
        
        RMQMAX rmq_max(R);  RMQMIN rmq_min(R);
        vector<int> ob(a.begin(), a.end()); sort(ob.begin(), ob.end()); ob.erase(unique(ob.begin(), ob.end()), ob.end());
        int no = ob.size();
        auto get = [&](int x) {
            return lower_bound(ob.begin(), ob.end(), x) - ob.begin() + 1;
        };

        for (int i = 0; i < n; i++) {
            add(root[i], root[i + 1], 1, no, get(a[i]), 1, a[i]);
        }

        vector<ll> res(m, -1);
        for (int i = 0; i < m; i++) {
            int l = qs[i][0], r = qs[i][1], mid = (r - l + 1 + 1) / 2;
            int mi = rmq_min.ask(l, r), mx = rmq_max.ask(l, r);
            if (mi != mx) {res[i] = -1; continue;}

            // 求中位数 v_mid
            int idx = ask_k_min(root[l], root[r + 1], 1, 1, no, mid); 
            int v_mid = ob[idx - 1];

            // 小于等于 中位数v_mid 的数量m_cnt 和 区间和m_sum
            Node node_delta = ask_sum_pre_now(root[l], root[r + 1], 1, 1, no, 1, get(v_mid));
            ll m_cnt = node_delta.val;
            ll m_sum = node_delta.val2;
            ll m_rst = sum[r + 1] - sum[l] - m_sum;
            ll delta = v_mid * m_cnt - m_sum + (m_rst - v_mid * ((r - l + 1) - m_cnt));
            res[i] = delta / K;
        }
        
        return res;
    }
};
```



##### 5 summary