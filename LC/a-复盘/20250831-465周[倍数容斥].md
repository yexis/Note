### T4 [3671. 子序列美丽值求和](https://leetcode.cn/problems/sum-of-beautiful-subsequences/)

##### 1 emphasis

- 倍数容斥



##### 2 key points

 

##### 3 thought



##### 4 code

1. 先计算满足条件 gcd=g的倍数 的严格递增子序列
2. 使用倍数容斥，计算每个g的答案

```cpp
using ll = long long;
const int mod = 1e9 + 7;
static constexpr int maxn = 70000;
vector<int> fac[maxn + 1];
int init = []() {
    for (int i = 1; i <= maxn; i++) {
        for (int j = i; j <= maxn; j += i) { 
            fac[j].push_back(i);
        }
    }
    return 0;
}();

struct BIT {
    int n;
    vector<ll> tr;
    BIT(int _n) {
        n = _n;
        tr.resize(n + 1);
    }
    int lb(int x) {
        return x & -x;
    }
    void add(int x, int u) {
        for (int i = x; i <= n; i += lb(i)) {
            tr[i] += u;
        }
    }
    ll ask(int x) {
        if (x == 0) return 0;
        ll ans = 0;
        for (int i = x; i > 0; i -= lb(i)) {
            ans += tr[i];
        }
        return ans;
    }
};

class Solution {
public:
    int totalBeauty(vector<int>& a) {
        int n = a.size();
        int mx = *max_element(a.begin(), a.end());

        // 按因子分组
        // 最大公因数恰好是g的递增子序列 一定 由 g 的倍数组成
        vector<int> group[mx + 1];
        for (auto& e : a) {
            for (auto& f : fac[e]) {
                group[f].push_back(e);
            }
        }

        // 计算单个组内的递增子序列个数
        // 这些递增子序列的gcd一定是g的倍数
        auto cal = [&](int g, vector<int>& b) {
            int n2 = b.size();

            // 离散化部分
            vector<int> ob = b;
            sort(ob.begin(), ob.end());
            ob.erase(unique(ob.begin(), ob.end()), ob.end());
            int n3 = ob.size();
            auto get = [&](int x) {
                return lower_bound(ob.begin(), ob.end(), x) - ob.begin() + 1;
            };

            ll ans = 0;
            BIT bit(n3);
            for (int i = 0; i < n2; i++) {
                int x = get(b[i]);
                ll cnt = bit.ask(x - 1) + 1; cnt %= mod;
                ans += cnt; ans %= mod;
                bit.add(x, cnt);
            }
            return ans;
        };

        // 计算出组内的递增子序列后
        // 使用倍数容斥
        ll ans = 0;
        ll f[mx + 1]; memset(f, 0, sizeof(f));
        for (int i = mx; i >= 1; i--) {
            f[i] = cal(i, group[i]);
            for (int j = i + i; j <= mx; j += i) {
                f[i] += mod - f[j]; f[i] %= mod;
            }
            ans += 1ll * i * f[i]; ans %= mod;
        }
        return ans;        
    }
};
```





##### 5 summary

