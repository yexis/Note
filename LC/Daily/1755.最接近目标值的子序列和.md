##### 1 emphasis
* 双指针
* 状态压缩


##### 2 key points

* 数组nums和一个目标值goal
* 从nums中选出一个子序列，如果子序列的和为sum，你需要 最小化绝对差 abs(sum - goal) 
* 返回 abs(sum - goal) 可能的 最小值
* 注: nums.size() <= 40

##### 3 thought



##### 4 code

```cpp
class Solution {
public:
	// 从数组num中选择所有可能的数字组合，并将它们的和存入数组sum
    void get_sum(vector<int>& sum, vector<int>& num){
        sum.push_back(0);
        for(int x : num){
            vector<int> nsum;
            int n = sum.size();
            for(int i = 0, j = 0; i < n or j < n;)
                if(i == n) nsum.push_back(sum[j ++] + x);
                else if(j == n) nsum.push_back(sum[i ++]);
                else if(sum[i] < sum[j] + x) nsum.push_back(sum[i ++]);
                else nsum.push_back(sum[j ++] + x);
            swap(nsum, sum);
        }
    }

    int minAbsDifference(vector<int>& nums, int goal) {
        vector<int> left, right;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (i < n / 2) {
                left.emplace_back(nums[i]);
            } else {
                right.emplace_back(nums[i]);
            }
        }
        // 将数组折半，得到两个数组a,b
        vector<int> a, b;
        get_sum(a, left);
        get_sum(b, right);

        // 使用双指针在两个有序列表中查询
        int ans = INT_MAX;
        int mm = a.size(), nn = b.size();
        int i = 0, j = nn - 1;
        while (i < mm && j >= 0) {
            ans = min(ans, abs(goal - (a[i] + b[j])));
            if (a[i] + b[j] <= goal) {
                i++;
            } else {
                j--;
            }
        }
        return ans;
    }
};
```

##### 5 summary
归并的条件: 两个数组需要同时升序或者同时降序
**单个数组的归并**
问题:在一个数组中，查询所有可能得数字组合，并计算个组合的和，并将其排序后返回
```cpp
// 方法一: 状态压缩  类似暴力的方法


```

