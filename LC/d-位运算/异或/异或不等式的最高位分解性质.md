### Title 异或不等式最高位分解性质

##### 1 emphasis



##### 2 key points

 **对于给定的$y,z$，所有满足 $x \bigoplus y \le z$的 $x$ 至多形成 $log(z)$ 个互不重叠的连续区间**

连续区间的数量，与$z$的二进制表示中 1的数量有关系



##### 3 thought

```cpp
// p 
// y = 10100
// z = 11010
// 则x的个数为 16 + 8 + 2 + 1(自身)

// step1: 
// ans += 16, p ^ x == [00000, 00001, ..., 01111]
// p = 0 _ _ _ _ 

// step2: 
// ans += 8, , p ^ x == [10000,10001,...,10111]
// p = 01 _ _ _ 

// step3: 
// ans += 0
// p = 011 _ _

// step4:
// ans += 2, p ^ x == [11000, 11001]
// p = 0111_

// step5:
// ans += 0
// p = 01110

// step6: 相等的情况
// 因为 (p ^ x) == y， 所以 ans += 1 
```



##### 4 code



```cpp
// 结论：对于给定的y,z，所有满足 (x ^ y <)= z的 x 至多形成 log(y) 个互不重叠的连续区间
// 计算这些区间
vector<array<int, 2>> get_xor_seg(int y, int z) {
    vector<array<int, 2>> seg;
    if (z < 0) return seg;

    int p = 0; // p在遍历的过程中，需要保证 p[i:max_bit] ^ y [i:max_bit] = z[i:max_bit]
    for (int i = max_bit - 1; i >= 0; i--) {
        if (z >> i & 1) { // z的该位是1
            if (y >> i & 1) {  // y的该位是1，说明x的该位需要是0
                seg.push_back({p | (1 << i), p | (1 << (i + 1)) - 1});
            } else { // y的该位是0，说明x的该位需要是1
                seg.push_back({p, p | (1 << i) - 1});
                p |= 1 << i;
            }
        } else { // z的该位是0
            if (y >> i & 1) { // y 的该位是 1，说明x的该位需要是1
                p |= 1 << i;
            }
        }
    }
    assert((p ^ y) == z);
    seg.push_back({p, p});
    return seg;
}
```

以上为不带范围限制的场景，可直接求出 $log(z)$个连续区间



**【拓展】**

若题目要求为求出满足 $x \in [L, R]$，且 $x \bigoplus y \le z$ 的 $x$ 的数量呢？

> 答案：在按上述方法求出所有区间后，再结合 $x \in [L, R]$的限制，进行 $l = max(l, L), r = min(r, R)$
>
> ```cpp
> for (auto& [l, r] : segr) {
>   l = std::max(0, l);
>   r = std::min(r, A[i]);
>   if (l > r) {
>     continue;
>   }
> }
> ```
>
> 



##### 5 summary

