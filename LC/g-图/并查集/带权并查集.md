### Title 带权并查集 

##### 1 emphasis

- 带权并查集



##### 2 key points

**要求：**

- 节点之间的关系存在传递性

  

 以**除法**为例：

- `weight[x]`表示x节点与其父亲`rx`的有向边的权重，$w = x / rx$
- 路径压缩：每个节点到父节点的距离不超过1（可能会延迟更新，``find`时）
- 合并时更新权值

```cpp
          ?
   rx --------> ry
    ^            ^
    | w_x        | w_y
    |            |
    x ---------> y
          v
            
// merge(a, b)时，find(a)、find(b)会分别将a、b直接指向根节点
// 此时 ? = w_b * v / w_a
// 所以合并时，有
// fa[] = ry
// weight[x] = weight[y] * v / wieght[x]
```



##### 3 thought





##### 4 code

- 除法 带权并查集

```cpp
struct DJ {
    int n;
    vector<int> fa;
    vector<double> weight;
    DJ(int _n) {
        n = _n;
        fa.resize(n);
        weight.resize(n, 1);
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        if (x != fa[x]) {
            // 这里注意：这里先保存x的父亲
            // 因为递归完后，x的父亲可能会变
            // 但是 weight[x] 还是等于 weight[x] * weight[原父亲] (此时 weight[原父亲]也变了)
            int ori = fa[x];
            fa[x] = find(fa[x]);
            // 更新weight
            weight[x] *= weight[ori];
        }
        return fa[x];
    }
    void merge(int x, int y, double v) {
        int rx = find(x);
        int ry = find(y);
        if (rx == ry) return;
        fa[rx] = ry;
        // 更新 weight
        weight[rx] = weight[y] * v / weight[x];
    }
    bool conn(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        return rx == ry;
    }
};

class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        int n = equations.size();
        DJ dj(2 * n);

        int nb = 0; 
        unordered_map<string, int> mp;
        for (int i = 0; i < n; i++) {
            auto& e = equations[i];
            string x = e[0], y = e[1]; // x / y = v
            if (!mp.count(x)) {
                mp[x] = nb++;
            }
            if (!mp.count(y)) {
                mp[y] = nb++;
            }
            dj.merge(mp[x], mp[y], values[i]);
        }
        
        vector<double> res;
        for (auto& q : queries) {
            string x = q[0];
            string y = q[1];
            if (!mp.count(x) || !mp.count(y)) {
                res.push_back(-1);
                continue;
            }
            if (!dj.conn(mp[x], mp[y])) {
                res.push_back(-1);
                continue;
            }
            res.push_back(dj.weight[mp[x]] / dj.weight[mp[y]]);
        }   
        return res;
    }
};
```



- 异或 带权并查集

```cpp
struct DJ {
    int n;
    vector<int> fa;
    vector<int> weight;
    DJ(int _n) {
        n = _n;
        fa.resize(n);
        weight.resize(n);
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        if (x != fa[x]) {
            int ori = fa[x];
            fa[x] = find(fa[x]);
            weight[x] ^= weight[ori];
        }
        return fa[x];
    }
    void merge(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx == ry) return;
        fa[rx] = ry;
        weight[rx] = weight[y] ^ 1 ^ weight[x];
    }
    bool conn(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        return rx == ry;
    }
};
class Solution {
public:
    using arr = array<int, 3>;
    const int inf = 2e9;
    int maxPartitionFactor(vector<vector<int>>& pts) {
        int n = pts.size();
        if (n == 2) return 0;

        auto cal = [&](int i, int j) -> int {
            return abs(pts[i][0] - pts[j][0]) + abs(pts[i][1] - pts[j][1]);    
        };

        int dist[n][n];
        vector<arr> ps;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                dist[i][j] = cal(i, j);
                ps.push_back(arr{dist[i][j], i, j});
            }
        }
        sort(ps.begin(), ps.end());

        DJ dj(n);
        for (auto& [dist, i, j] : ps) {
            if (dj.conn(i, j)) {
                if (dj.weight[i] == dj.weight[j]) {
                    return dist;
                }
                continue;
            }
            dj.merge(i, j);
        }
        return -1;
    }
};
```





##### 5 summary