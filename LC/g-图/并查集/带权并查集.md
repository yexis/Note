### Title 带权并查集 

##### 1 emphasis

- 带权并查集



**减法、除法、异或**



##### 2 key points

**要求：**

- 节点之间的关系存在传递性

  

 以**除法**为例：

- `weight[x]`表示x节点与其父亲`rx`的有向边的权重，$w = x / rx$
- 路径压缩：每个节点到父节点的距离不超过1（可能会延迟更新，``find`时）
- 合并时更新权值

```cpp
          ?
   rx --------> ry
    ^            ^
    | w_x        | w_y
    |            |
    x ---------> y
          v
            
// merge(a, b)时，find(a)、find(b)会分别将a、b直接指向根节点
// 此时 ? = w_b * v / w_a
// 所以合并时，有
// fa[] = ry
// weight[x] = weight[y] * v / wieght[x]
```



##### 3 thought





##### 4 code

- **减法** 带权并查集 https://ac.nowcoder.com/acm/contest/123149/F
- 考虑虚拟一个节点是否好做一些

```cpp
#include <iostream>
#include <vector>
#include <string.h>
#include <algorithm>
#include <numeric>
#include <set>
#include <array>
#include <cassert>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
#include <vector>
#include <queue>
#include <stack>
#include <list>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <algorithm>
#include <complex>
#include <cmath>
#include <numeric>
#include <bitset>
#include <functional>
#include <random>
#include <ctime>
#include <limits>
#include <climits>

using namespace std;
#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define next_per next_permutation
#define call(x) (x).begin(), (x).end()
#define debug(x) cout << (#x) << " = " << (x) << endl;
#define debugout(x) cout << (#x) << " = " << (x) << endl;
#define debugerr(x) cerr << (#x) << " = " << (x) << endl;

using ll = long long;
using ull = unsigned long long;
using pii = pair<int, int>;
using pli = pair<ll, int>;
using pil = pair<int, ll>;
using pll = pair<ll, ll>;
using pbi = pair<bool, int>;
using pib = pair<int, bool>;
using pis = pair<int, string>;
using psi = pair<string, int>;
using puu = pair<ull, ull>;
using arr = array<int, 3>;
using arr3 = array<int, 3>;
using arr4 = array<int, 4>;
using arr5 = array<int, 5>;

const int dir[4][2] = {{-1, 0},
                       {1,  0},
                       {0,  -1},
                       {0,  1}};
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const int mod = 1e9 + 7;
const string YES = "YES";
const string NO = "NO";

ll power(ll x, ll b, ll m = mod) {
    ll ans = 1;
    while (b) {
        if (b & 1) {
            ans *= x;
            ans %= m;
        }
        x *= x;
        x %= m;
        b >>= 1;
    }
    return ans;
}

/*
 * 
*/

struct DJ {
    int n;
    vector<int> fa;
    vector<ll> weight;
    DJ(int _n) {
        n = _n;
        fa.resize(n);
        weight.resize(n, 0);
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        if (x != fa[x]) {
            // 这里注意：这里先保存x的父亲
            // 因为递归完后，x的父亲可能会变
            int ori = fa[x];
            fa[x] = find(fa[x]);
            // 更新weight
            weight[x] += weight[ori];
        }
        return fa[x];
    }
    // x - y = v
    // x -> y 默认将y设置成x的父亲
    ll merge(int x, int y, ll v) {
        int rx = find(x);
        int ry = find(y);
      	// weight[rx] 即将等于 nd
        ll nd = weight[y] + v - weight[x];
        // 如果已经处于相同联通块，说明ru == rv
        // 那么weight[x]必须是0
        if (rx == ry) {
            if (nd != 0) return 0;
            return v;
        }
    
        fa[rx] = ry;
        // 更新 weight
        weight[rx] = nd;
        return v;
    }
    bool conn(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        return rx == ry;
    }
};

void solve() {
    int n, q; cin >> n >> q;
    DJ dj(n + 4);
    while (q--) {
        int op; cin >> op;
        if (op == 1) {
            ll u, v, k; cin >> u >> v >> k;
            int ret = dj.merge(u, v, k);
            if (ret) {
                cout << "OK" << "\n";
            } else {
                cout << "CONTRADICTION" << "\n";
            }
        } else if (op == 2) {
            ll u, k; cin >> u >> k;
            // 赋值操作
            // 就是将节点u与虚拟节点n+1合并
            // 且 dis[u] = k;
            int ret = dj.merge(u, n + 1, k);
            if (ret) {
                cout << "OK" << "\n";
            } else {
                cout << "CONTRADICTION" << "\n";
            }
        } else if (op == 3) {
            ll u, v; cin >> u >> v;
            if (dj.conn(u, v)) {
                cout << dj.weight[u] - dj.weight[v] << "\n";
            } else {
                cout << "UNKNOWN" << "\n";
            }

        }
    }  
}

int main() {
    ios;
    cout << fixed << setprecision(20);

    int T = 1; 
    cin >> T;
    while (T--) {
    	solve();
    }
    return 0;
}

```





- **除法** 带权并查集

```cpp
struct DJ {
    int n;
    vector<int> fa;
    vector<double> weight;
    DJ(int _n) {
        n = _n;
        fa.resize(n);
        weight.resize(n, 1);
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        if (x != fa[x]) {
            // 这里注意：这里先保存x的父亲
            // 因为递归完后，x的父亲可能会变
            // 但是 weight[x] 还是等于 weight[x] * weight[原父亲] (此时 weight[原父亲]也变了)
            int ori = fa[x];
            fa[x] = find(fa[x]);
            // 更新weight
            weight[x] *= weight[ori];
        }
        return fa[x];
    }
    void merge(int x, int y, double v) {
        int rx = find(x);
        int ry = find(y);
        if (rx == ry) return;
        fa[rx] = ry;
        // 更新 weight
        weight[rx] = weight[y] * v / weight[x];
    }
    bool conn(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        return rx == ry;
    }
};

class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        int n = equations.size();
        DJ dj(2 * n);

        int nb = 0; 
        unordered_map<string, int> mp;
        for (int i = 0; i < n; i++) {
            auto& e = equations[i];
            string x = e[0], y = e[1]; // x / y = v
            if (!mp.count(x)) {
                mp[x] = nb++;
            }
            if (!mp.count(y)) {
                mp[y] = nb++;
            }
            dj.merge(mp[x], mp[y], values[i]);
        }
        
        vector<double> res;
        for (auto& q : queries) {
            string x = q[0];
            string y = q[1];
            if (!mp.count(x) || !mp.count(y)) {
                res.push_back(-1);
                continue;
            }
            if (!dj.conn(mp[x], mp[y])) {
                res.push_back(-1);
                continue;
            }
            res.push_back(dj.weight[mp[x]] / dj.weight[mp[y]]);
        }   
        return res;
    }
};
```



- **异或** 带权并查集

```cpp
struct DJ {
    int n;
    vector<int> fa;
    vector<int> weight;
    DJ(int _n) {
        n = _n;
        fa.resize(n);
        weight.resize(n);
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        if (x != fa[x]) {
            int ori = fa[x];
            fa[x] = find(fa[x]);
            weight[x] ^= weight[ori];
        }
        return fa[x];
    }
    void merge(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx == ry) return;
        fa[rx] = ry;
        weight[rx] = weight[y] ^ 1 ^ weight[x];
    }
    bool conn(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        return rx == ry;
    }
};
class Solution {
public:
    using arr = array<int, 3>;
    const int inf = 2e9;
    int maxPartitionFactor(vector<vector<int>>& pts) {
        int n = pts.size();
        if (n == 2) return 0;

        auto cal = [&](int i, int j) -> int {
            return abs(pts[i][0] - pts[j][0]) + abs(pts[i][1] - pts[j][1]);    
        };

        int dist[n][n];
        vector<arr> ps;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                dist[i][j] = cal(i, j);
                ps.push_back(arr{dist[i][j], i, j});
            }
        }
        sort(ps.begin(), ps.end());

        DJ dj(n);
        for (auto& [dist, i, j] : ps) {
            if (dj.conn(i, j)) {
                if (dj.weight[i] == dj.weight[j]) {
                    return dist;
                }
                continue;
            }
            dj.merge(i, j);
        }
        return -1;
    }
};
```





##### 5 summary