### Title 并查集

##### 1 emphasis

- 并查集
- 联通分量



##### 2 key points

 

##### 3 thought



##### 4 code

```cpp
struct DJ {
    vector<int> fa;
    vector<int> ra;
    vector<int> cnt; // 每个连通分量的大小
  	int v; // 联通块的总数
    int n;
    DJ(int _n) {
        n = _n;
      	v = _n;
        fa.resize(n);
        ra.resize(n);
        cnt.resize(n);
        iota(fa.begin(), fa.end(), 0);
    }

    int find(int x) {
        if (x != fa[x]) {
            fa[x] = find(fa[x]);
        }
        return fa[x];
    }

    void merge(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx == ry) {
            return;
        }
        if (ra[rx] < ra[ry]) {
            swap(rx, ry);
        }
      	v--;
        fa[ry] = rx;
        cnt[rx] += cnt[ry];
        if (ra[rx] == ra[ry]) {
            ra[rx]++;
        }
    }

  	bool conn(int x, int y) {
    	return find(x) == find(y);
    }
};
```





##### 使用并查集无向图判环

```cpp
struct DJ {
    int n;
    vector<int> fa;
  	// 记录连通分量中节点数和边数
    vector<int> ver, edge;
    DJ(int nn) {
        n = nn;
        fa.resize(n);
        iota(fa.begin(), fa.end(), 0);
        
        ver.assign(n, 1);
        edge.assign(n, 0);
    }
    int find(int x) {
        if (x != fa[x]) {
            fa[x] = find(fa[x]);
        }
        return fa[x];
    }
    void merge(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx == ry) {
            edge[rx] += 1;
            return;
        }
        
        fa[ry] = rx;
        ver[rx] += ver[ry];
        ver[ry] = 0;
        edge[rx] += edge[ry] + 1;
        edge[ry] = 0;
    }
    bool conn(int x, int y) {
        return find(x) == find(y);
    }
};
```





##### 5 summary

