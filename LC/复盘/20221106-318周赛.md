### T2 2461.长度为K子数组中的最大和  wa*2

##### emphasis

固定长度滑动窗口



##### key points

* 长度为 $k$    ---->   固定长度的滑窗解法

* 子数组元素各不相同   ----> 使用$map$，当 $map[i] == 0$ 时，erase即可  

* 和最大   ---->    使用 $sum$ 保存窗口中的元素和

  

##### 方法1 : 固定长度的滑窗 一定按这种方式来

1. 先初始化前 $K$ 个元素 $[0:k-1]$
2. $ans$ 根据 $[0:k-1]$ 是否满足条件 $cond$ 进行初始化赋值
3. 窗口向右滑动，右侧入一个元素，左侧出一个元素
4. 判断 状态 $[l,r]$ 是否满足条件 $cond$  更新结果 $ans$
5. 返回最终结果 $ans$

```cpp
class Solution {
public:
	unordered_map<int, int> um;
    long long maximumSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        long long sum = 0;
        for (int i = 0; i < k; i++) {
            um[nums[i]]++;
            sum += nums[i];
        }
        long long ans = (um.size() == k ? sum : 0);

        for (int i = k; i < n; i++) {
            sum -= nums[i - k];
            if (--um[nums[i - k]] == 0) {
                um.erase(nums[i - k]);
            }

            sum += nums[i];
            um[nums[i]]++;
            if (um.size() == k) {
                ans = max(ans, sum);
            }
        }
        return ans;
    }
};
```





### T3 2462.雇佣K为工人的总代价 wa*1

##### emphasis

堆 priority_queue



##### key points

* 数组 $costs$，进行 $k$ 轮操作

* 每轮操作从左侧 $can$ 个元素和右侧 $can$ 个元素中取出最小的元素，取出后再扩展至 $can$ 个元素

* 如果数组元素不足 $can$，则选出最小元素的即可

* 计算 $k$ 轮操作后所有取出 $cost[i]$ 的和

  

##### 方法1 : 双堆（自己的做法）

1. 维护左堆和右堆，两个堆中的元素个数都为 $can$
2. 每轮操作从两个堆中弹出最小的元素$x,y$，并扩展取值的堆 $x$ 或 $y$
3. 左堆扩展到数组结尾位置结束，右堆扩展到数组开头位置结束
4. **注意 : 左堆和右堆的数组可能会重复，避免元素 $x$ 被重复加入到左堆和右堆，需要记录元素 $x$(下标 $i$ )是否被加入过**
5. **特点 : 允许重复元素的加入，需用set判重**

```cpp
class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int can) {
        int n = costs.size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<> > pq1, pq2;
        int l = can - 1, r = n - can;
        for (int i = 0; i < can; i++) {
            pq1.emplace(costs[i], i);
        }
        
        for (int i = 0; i < can; i++) {
            int j = n - 1 - i;
            pq2.emplace(costs[j], j);
        }
        
        set<int> st;
        long long ans = 0;
        for (int i = 0; i < k; i++) {
            auto [x, idx1] = pq1.top();
            auto [y, idx2] = pq2.top();
            
            if (idx1 == idx2) {
                ans += x;
                st.insert(idx1);
                pq1.pop();
                pq2.pop();
                
                l++;
                while (l < n && st.count(l)) {
                    l++;
                }
                if (l < n) {
                    pq1.emplace(costs[l], l);
                }
                
                r--;
                while (r >= 0 && st.count(r)) {
                    r--;
                }
                if (r >= 0) {
                    pq2.emplace(costs[r], r);
                }
                continue;
            }
            
            if (x <= y) {
                ans += x;
                st.insert(idx1);
                pq1.pop();
                l++;
                while (l < n && st.count(l)) {
                    l++;
                }
                if (l < n) {
                    pq1.emplace(costs[l], l);
                }
            } else {
                ans += y;
                st.insert(idx2);
                pq2.pop();
                r--;
                while (r >= 0 && st.count(r)) {
                    r--;
                }
                if (r >= 0) {
                    pq2.emplace(costs[r], r);
                }
            }
            
        }
        return ans;
    }
};
```



##### 方法2 : 单个堆

1. 使用单个堆 `pq`，同时记录左边和右边的 $2 * can$ 个元素
2. 使用 $L$ 和 $R$ 记录左、右两边界
3. $L$ 向结尾扩展，$R$ 向开头扩展，$L=R$ 时结束
4. **注意 : 这种方法从根本上保证了元素不会重复添加到队列中**
5. **特点 : 不需要判重，但是代码细节更多**

```cpp
class Solution {
public:
    long long totalCost(vector<int>& nums, int k, int can) {
        int n = nums.size();
        int L = can - 1, R = n - 1;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<> > pq; 
        for (int i = 0; i < can; i++) {
            pq.emplace(nums[i], i);
        }
        for (int i = 0; i < can; i++) {
            int j = n - i - 1;
            if (j > L) {
                pq.emplace(nums[j], j);
                R = j;
            }
        }
        
        long long ans = 0;
        for (int i = 0; i < k; i++) {
            auto [v, u] = pq.top();
            pq.pop();
            ans += v;
            if (u <= L) {
                if (L + 1 < R) {
                    L++;
                    pq.emplace(nums[L], L);
                }
            } else if (u >= R) {
                if (R - 1 > L) {
                    R--;
                    pq.emplace(nums[R], R);
                }
            }
        }

        return ans;
    }
};
```



### T4 2463.最小移动距离

##### emphasis

动态规划



##### 定理

在数轴上，如果需要将 $x$ 个车分配给 $y$ 个站点，则分给每个站点的车，在数轴上是连续排列的



##### key points

* 不重复整数数组 $robot$，代表每个机器人的位置
* 不重复二维整数数组 $factory$，代表每个工厂的位置和能修理的机器人数
* 机器人必须由某个工厂修理
* 机器人必须移动到某工厂才能被工厂修复
* 计算修复所有机器人，需要移动的最小距离



##### 方法1 : 记忆化搜索

1. $f[i][j]$ 表示使用 $[i,m-1]$ 个工厂修理 $[j, n-1]$ 个机器人的最小移动距离
2. $f[i][j]$ 可以由 $f[i+1][k]$ 转移而来，其中，$k = j + 1, j + 2,..., j + factory[i][1]$
3. 最终结果返回  $f[0][0]$

```cpp
class Solution {
public:
    const long long inf = 1e15;
    int m;
    int n;
    vector<vector<int> > fa;
    vector<int> ro;
    long long f[101][101];
  	// 返回数轴上坐标x与坐标y之间的距离
    long long get(int x, int y) {
        return 0l + abs(x - y);
    }
    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {
        memset(f, -1, sizeof(f));
        this->ro = robot;
        this->fa = factory;
        m = fa.size();
        n = ro.size();

        sort(fa.begin(), fa.end());
        sort(ro.begin(), ro.end());
        return dfs(0, 0);
    }

    // f[i][j] 表示 使用[i, m - 1] 个工厂修复 [j, n - 1] 个机器人的最小移动距离
    long long dfs(int i, int j) {
        if (j == n) {
            return 0;
        }
        // 修理剩余的机器人
        if (i == m - 1) {
            if (n - j > fa[i][1]) {
                return inf;
            }
            long long ans = 0;
            for (int k = j; k < n; k++) {
                ans += get(ro[k], fa[i][0]);
            }
            return ans;
        }
        // 记忆化
        if (f[i][j] != -1) {
            return f[i][j];
        }

        long long ans = dfs(i + 1, j);
        long long sum = 0;
        int k = 1;
        while (k <= fa[i][1] && j + k - 1 < n) {
            sum += get(ro[j + k - 1], fa[i][0]);
            ans = min(ans, sum + dfs(i + 1, j + k));
            k++;
        }
        return f[i][j] = ans;
    }
};
```

