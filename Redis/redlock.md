## 分布式锁



分布式锁的本质是在Redis里面占一个“坑”，当别的进程也要过来占坑时，发现已经有了一个，就只能放弃或者稍后再试。



### 1.千帆过尽

占坑使用 `setnx (set if not exist)`指令

```go
//设置锁
setnx mylock true
//删掉锁
del mylock
```



问题： 由于`setnx`和`del`不是原子操作，如果程序执行到中间出现了异常，可能会导致`del`没有被调用，陷入死锁，锁永远得不到释放。



所以

在拿到锁之后，一般会设置一个过期时间，锁到期后会自动释放 

```go
//设置锁
setnx mylock true
//设置过期时间
expire mylock 5
//删除锁
del mylock
```



但是

以上逻辑仍然会存在问题，如果`setnx` 和`expire` 之间服务器进程挂掉了，导致 `expire` 无法执行，也会造成死锁

根源还是在于`setnx` and  `expire`不是原子操作。



是否可以使用事务解决？

否，`expire`的执行是依赖`setnx`的执行结果的，如果`setnx`没有抢到锁，`expire`是不应该执行的。

但，redis事务中是没有`if else`逻辑的。事务就是要么都执行，要么都不执行。



解决方法

redis2.8版本，作者加入了`set`  执行的扩展参数，使得`setnx`和`expire`可以一起执行

```go
//设置锁
set mylock true ex 5 nx
//删除锁
del mylock
```



#### 超时问题

Redis分布式锁不能解决超时问题，如果在加锁和解锁之间的逻辑执行的太长，超出了锁的时间限制，就会出现问题。

为了避免这个问题，Redis分布式锁不要用于较长时间的任务。



一个稍微安全点的方案

将`set`指令的`value`参数设置为一个随机数，释放锁时需要先匹配随机数是否一致，然后再删除`key`，这是为了确保当前线程占有的锁不会被其他线程释放，除非这个锁是因为过期被服务器自动释放的。

伪代码：

```go
tag = random.nextInt() 
if redis.set(key, tag, nx=true, ex = 5):
do_something() 
redis.delifequals(key, tag) // 假想的指令
```

但是匹配`value`和删除`key`不是原子操作。





#### 可重入性

定义：

线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁是可重入的





### 2.查漏补缺

虽然，一条指令就可以完成加锁操作，

但是，在集群环境下，这种方式是由缺陷的，非绝对安全的。



无图

遐想

在Sentinel集群中，当主节点挂掉时，从节点会去而代之

但，客户端上并没有明显的感知

比如

原先A客户端在主节点中申请成功了一把锁，但是这把锁还没来得及主从同步，主节点突然挂掉了

然后从节点变成了主节点

此时，新的主节点内部没有这把锁

所以，当另一个客户端过来请求加锁时，立即就批准了。

这样，就会导致系统中同样一把锁被两个客户端同时持有，产生不安全性。



#### RedLock算法

为了使用RedLock算法，需要提供多个redis实例

这些实例之间相互独立，没有主从关系



算法

加锁时，它会向过半节点发送`set(key, value, nx=True, ex=xxx)` 指令

只要过半节点`set`成功，就认为加锁成功

释放锁时，需要向所有节点发送`del`指令



由于Redlock算法需要向多个节点进行读写，意味着其相比单实例Redis的性能会下降一些。



使用场景

如果非常在乎高可用性

希望挂了一台Redis也完成不受影响





#### 